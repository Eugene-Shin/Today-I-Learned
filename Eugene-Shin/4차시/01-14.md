# 4차시(1/14) - 아키텍처와 어노테이션, JPA
### 계층형 아키텍처
- 구조
	- controller - 프론트의 http 요청 처리(파라미터 바인딩 등)
	- service - 비즈니스 로직 작성
	- domain - ddl
	- repository - db에서 어떻게 데이터 가져올지 등 설정
	- dto - data transfer object, 어떤 데이터 가져와 불변 객체로 쓸지
- 장점
	- 역할 분담 명확
	- 구조 직관적

### 어노테이션
- 컴파일러에게 무슨 행동 할 건지 알려줌
- 컴파일 시점 오류 감지, validation(runtime 오류 잡기) 등
- 프론트엔드 요청 -> controller -> service -> repository -> db -> 다시 역순으로 돌아가 응답
- RestController
	- GET/POST
	- 어떤 엔드포인트에 매핑할지
	- 어떤 서비스 호출할지
	- 그 정도만 정의하면 돼서 controller 단은 짧음

### Controller vs RestController
- **맨 처음 프로젝트 생성 후에 src 폴더를 Mark Directory As Sources Root로 설정해야 함**
- GetMapping 등의 어노테이션으로 엔드포인트를 지정
- Controller
	- 정적 리소스를 view로 반환
	- 브라우저에서 localhost:8080/endpoint에 GET 요청 보내면 WEBINF 등에서 반환값 이름을 갖는 정적 리소스 찾아 반환(thymeleaf에서는 templates) -> 화면에 html 해석해서 보여줌
	- ThunderClient 등의 도구로 GET 요청 보내면 해당 html 파일의 내용이 옴
- RestController
	- Controller + ResponseBody
	- 반환 값을 그대로 보내줌
	- 주로 Map 자료형 사용해서 json qhsoa
	- ThunderClient 등의 도구로 GET 요청 보내면 해당 json 파일이 옴

### ORM vs SQL mapper
- ORM
	- 내가 쓰는 언어로 SQL 작성
	- 객체로 관계형 데이터베이스 mapping
	- domain에서 작성하는 클래스 자동 변환
	- repository에서 작성한 crud 자동 변환
	- 한 번 변환해야 해서 살짝 느림
	- ORM으로 작성하면 DB 상관없이 사용 가능(관계형 DB만, Mongo DB 같은 건 안됨)
	- jpa가 ORM 위한 자바 표준
		- 영속성 context
		- entity
		- jpql
		- hibernate는 spring에서 사용하는 jpa 구현체
		- m + 1 문제 발생 가능
			- 나는 쿼리 하나만 보냈다고 생각했는데 하나 더 보내지는 문제
- SQL mapper
	- xml 코드에 작성
	- xml 내부 로직만 바꾸면 굳이 컴파일 안 해도 됨
	- 서비스 돌아가는 도중에도 xml 파일만 바꿔끼면 됨
	- SQL로 작성해서 해당 DB에 친화적이라 엄청 빠름

### DBeaver 연동
1. Docker container로 mysql 띄우기
	- docker run -d --name mysql-spring -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -e MYSQL_DATABASE=spring  mysql:latest
2. terminal에서 docker의 mysql 실행
	- docker exec -it mysql-spring mysql -u root -p