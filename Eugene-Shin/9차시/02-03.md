# 9차시(2/3) - JPQL, CORS
### jpql
- 쿼리가 여러 번 나가는 경우 하나로 묶어주기 위해 사용
- hibernate가 쿼리 만들어 커넥션에 넣어 DB에 쏘도록 하지 않고 직접 SQL 쿼리 작성
- Repository단에 메소드 작성
	- `@Query`
		- 기본 JPQL(엔티티 기준, 자바 객체 대상으로 쿼리 작성)
		- Hibernate 6 기준으로 case문 사용 불가
	- `@NativeQuery`
		- 진짜 SQL 문법으로 작성(DB 기준)
- 예시
  ```@Query("""
	    select f.friend
	    from Friend f
	    where f.owner.id = :userId
	""")
	List<User> findFriends(@Param("userId") Long userId);
  ```

### DBeaver SQL
1. OpenSQL Script 눌러 새 스크립트 작성
2. `command` + `Enter`로 파라미터 바인딩 가능(변수 역할)

### CORS
- 다른 origin(protocol + domain + port)으로 resource를 보내거나 받는 것이 기본적으로 금지되어 있음
- 해결하려면 서버에서 cors 에러를 잡아 주어야 함
	- config 패키지 만들어 CorsConfig.class 생성
```java
package com.example.demo.config;  
  
import org.springframework.context.annotation.Configuration;  
import org.springframework.web.servlet.config.annotation.CorsRegistry;  
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;  
  
@Configuration  
public class CorsConfig implements WebMvcConfigurer {  
  
    @Override  
    public void addCorsMappings(CorsRegistry registry) {  
        registry.addMapping("/**")  
                .allowedOrigins("http://localhost:5173")  
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")  
                .allowedHeaders("*")  
                .allowCredentials(true)  
                .maxAge(3600);  
    }  
}
```

- Spring Security 사용하는 경우
```java
package com.example.demo.config;  
  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.web.cors.CorsConfiguration;  
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;  
import org.springframework.web.cors.CorsConfigurationSource;  
  
import java.util.List;  
  
@Configuration  
public class CorsConfig {  
  
    @Bean  
    public CorsConfigurationSource corsConfigurationSource() {  
        CorsConfiguration config = new CorsConfiguration();  
  
        config.setAllowedOrigins(List.of("http://localhost:5173"));  
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));  
        config.setAllowedHeaders(List.of("*"));  
        config.setAllowCredentials(false);  
        config.setMaxAge(3600L);  
  
        UrlBasedCorsConfigurationSource source =  
                new UrlBasedCorsConfigurationSource();  
        source.registerCorsConfiguration("/**", config);  
  
        return source;  
    }  
}
```

### git submodule
1.  `git clone {레포 url} {폴더명}`으로 clone 받은 레포지토리 최상위 루트에서
2. `git submodule add {private 레포 url} Secret`으로 submodule 추가하면 폴더명 Secret으로 서브모듈이 생김
3. `git submodule update --init --recursive`도 실행해 주고
4. 해당 폴더 안에 `application.yml` 파일 만들어 사용
5. 해당 파일 수정 시 서브모듈 폴더 내부에서 `git add .`, `git commit -m "..."`, `git push`해 주고
6. 바깥 레포에서도 `git add .`, `git commit -m "..."`, `git push`해 줘야 git이 변경된 해시 값 추적 및 업로드 가능
7. spring boot의 auto configuration 기본 classpath가 resources로 잡혀 있으므로 resources 폴더 내로 yml 파일을 옮겨 줘야 함
	- build.gradle에서 새 태스크 추가해서 해당 태스크만 실행하면 수정된 Secret 서브모듈 안의 yml 파일을 resources 폴더로 옮기도록 할 수 있음
		- build.gradle 파일의 task 각각이 java 코드로 치환 가능한 실행할 수 있는 코드임(실행 버튼도 뜨니까)
8. 쉽게 yml 파일을 바꿔 가며 실행할 수 있음
```yml
//.../resources/application.yml
spring:
	profiles:
		active: local  //이 부분만 바꾸면 실행하는 yml 파일이 바뀜
```
```yml
//.../resources/application-local.yml or application-deploy.yml
spring:
	...
```

### 세션, 쿠키 vs jwt
- 쿠키는 브라우저가 관리
- session은 서버가 관리
- jwt를 쓰면 session 이전 상태를 관리하지 않아도 됨(무상태성 유지)
- http는 연결 없이 송수신하기 위한 프로토콜
- 소셜로그인 jwt 구현
	- 1단계(게스트 권한)
		- auth2로 해당 소셜 미디어에게 jwt 토큰 발급받아 로그인
		- 헤더에서 interceptor 함수로 아이디 등을 뽑아 옴
		- mysql 테이블에서 findBySocialIdAndProvider로 lookup해서 jwt 토큰(ROLE_GUEST) 발급
	- 2단계(유저 권한)
		- 해당 유저가 최초 로그인하면 사용자 정보 form 입력 받아 테이블에 저장
		- 유저 권한 부여(jwt 토큰을 ROLE_USER로 재발급)
	- redis cache에 유저의 소셜 id와 pk, provider를 저장해 두고 조회하면 mysql보다 훨씬 빠름(비쌈)